-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (extends Supabase auth.users)
CREATE TABLE public.users (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone TEXT,
  age INTEGER CHECK (age >= 18 AND age <= 100),
  location TEXT,
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Personality quiz results
CREATE TABLE public.personality_quiz_results (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  answers JSONB NOT NULL,
  bio TEXT,
  personality_traits JSONB NOT NULL,
  match_preferences JSONB NOT NULL,
  property_preferences JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  UNIQUE(user_id)
);

-- Properties
CREATE TABLE public.properties (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  owner_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  location TEXT NOT NULL,
  rent_per_week DECIMAL(10,2) NOT NULL CHECK (rent_per_week > 0),
  available_rooms INTEGER NOT NULL CHECK (available_rooms > 0),
  total_rooms INTEGER NOT NULL CHECK (total_rooms > 0),
  property_type TEXT NOT NULL CHECK (property_type IN ('house', 'apartment', 'townhouse', 'studio')),
  amenities TEXT[] DEFAULT '{}',
  images TEXT[] DEFAULT '{}',
  property_preferences JSONB,
  target_locations TEXT[],
  is_active BOOLEAN DEFAULT TRUE,
  available_from DATE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  CHECK (available_rooms <= total_rooms)
);

-- Chat rooms
CREATE TABLE public.chat_rooms (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  participants UUID[] NOT NULL,
  last_message_id UUID,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  CHECK (array_length(participants, 1) >= 2)
);

-- Chat messages
CREATE TABLE public.chat_messages (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  room_id UUID REFERENCES public.chat_rooms(id) ON DELETE CASCADE NOT NULL,
  sender_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  message_type TEXT DEFAULT 'text' CHECK (message_type IN ('text', 'property_share', 'marketplace_item')),
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Marketplace items
CREATE TABLE public.marketplace_items (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  seller_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  price DECIMAL(10,2) NOT NULL DEFAULT 0 CHECK (price >= 0),
  category TEXT NOT NULL CHECK (category IN ('furniture', 'electronics', 'household', 'books', 'clothing', 'other')),
  condition TEXT NOT NULL CHECK (condition IN ('new', 'like_new', 'good', 'fair', 'poor')),
  images TEXT[] DEFAULT '{}',
  is_available BOOLEAN DEFAULT TRUE,
  is_free BOOLEAN DEFAULT FALSE,
  location TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Matches (generated by AI compatibility algorithm)
CREATE TABLE public.matches (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  matched_user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  compatibility_score INTEGER NOT NULL CHECK (compatibility_score >= 0 AND compatibility_score <= 100),
  match_reasons TEXT[],
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'expired')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  UNIQUE(user_id, matched_user_id),
  CHECK (user_id != matched_user_id)
);

-- Property views/interests
CREATE TABLE public.property_interests (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  property_id UUID REFERENCES public.properties(id) ON DELETE CASCADE NOT NULL,
  interest_type TEXT NOT NULL CHECK (interest_type IN ('viewed', 'favorited', 'contacted')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- Update triggers for updated_at columns
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc', NOW());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_personality_quiz_results_updated_at BEFORE UPDATE ON public.personality_quiz_results FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_properties_updated_at BEFORE UPDATE ON public.properties FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_chat_rooms_updated_at BEFORE UPDATE ON public.chat_rooms FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_marketplace_items_updated_at BEFORE UPDATE ON public.marketplace_items FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_matches_updated_at BEFORE UPDATE ON public.matches FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Update chat room's last_message_id when new message is added
CREATE OR REPLACE FUNCTION update_chat_room_last_message()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.chat_rooms 
    SET last_message_id = NEW.id, updated_at = TIMEZONE('utc', NOW())
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_chat_room_last_message_trigger 
AFTER INSERT ON public.chat_messages 
FOR EACH ROW EXECUTE FUNCTION update_chat_room_last_message();

-- Row Level Security (RLS) policies
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.personality_quiz_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.properties ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.marketplace_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.property_interests ENABLE ROW LEVEL SECURITY;

-- Users can read all user profiles but only update their own
CREATE POLICY "Users can view all profiles" ON public.users FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.users FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can insert own profile" ON public.users FOR INSERT WITH CHECK (auth.uid() = id);

-- Personality quiz results - users can only access their own
CREATE POLICY "Users can access own quiz results" ON public.personality_quiz_results FOR ALL USING (auth.uid() = user_id);

-- Properties - all can view active properties, owners can manage their own
CREATE POLICY "Anyone can view active properties" ON public.properties FOR SELECT USING (is_active = true);
CREATE POLICY "Property owners can manage their properties" ON public.properties FOR ALL USING (auth.uid() = owner_id);

-- Chat rooms - participants can access their rooms
CREATE POLICY "Participants can access their chat rooms" ON public.chat_rooms FOR ALL USING (auth.uid() = ANY(participants));

-- Chat messages - participants of the room can access messages
CREATE POLICY "Room participants can access messages" ON public.chat_messages FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.chat_rooms 
    WHERE id = room_id AND auth.uid() = ANY(participants)
  )
);
CREATE POLICY "Room participants can send messages" ON public.chat_messages FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.chat_rooms 
    WHERE id = room_id AND auth.uid() = ANY(participants)
  ) AND auth.uid() = sender_id
);

-- Marketplace - all can view available items, sellers can manage their own
CREATE POLICY "Anyone can view available marketplace items" ON public.marketplace_items FOR SELECT USING (is_available = true);
CREATE POLICY "Sellers can manage their items" ON public.marketplace_items FOR ALL USING (auth.uid() = seller_id);

-- Matches - users can view matches involving them
CREATE POLICY "Users can view their matches" ON public.matches FOR SELECT USING (auth.uid() = user_id OR auth.uid() = matched_user_id);
CREATE POLICY "Users can update match status" ON public.matches FOR UPDATE USING (auth.uid() = user_id OR auth.uid() = matched_user_id);

-- Property interests - users can manage their own interests
CREATE POLICY "Users can manage their property interests" ON public.property_interests FOR ALL USING (auth.uid() = user_id);

-- Create indexes for better performance
CREATE INDEX idx_users_email ON public.users(email);
CREATE INDEX idx_users_location ON public.users(location);
CREATE INDEX idx_properties_location ON public.properties(location);
CREATE INDEX idx_properties_rent ON public.properties(rent_per_week);
CREATE INDEX idx_properties_active ON public.properties(is_active);
CREATE INDEX idx_chat_messages_room_id ON public.chat_messages(room_id);
CREATE INDEX idx_chat_messages_created_at ON public.chat_messages(created_at);
CREATE INDEX idx_marketplace_items_location ON public.marketplace_items(location);
CREATE INDEX idx_marketplace_items_category ON public.marketplace_items(category);
CREATE INDEX idx_marketplace_items_available ON public.marketplace_items(is_available);
CREATE INDEX idx_matches_user_id ON public.matches(user_id);
CREATE INDEX idx_matches_compatibility_score ON public.matches(compatibility_score);

-- Function to automatically create user profile when they sign up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, first_name, last_name)
  VALUES (NEW.id, NEW.email, COALESCE(NEW.raw_user_meta_data->>'first_name', 'User'), COALESCE(NEW.raw_user_meta_data->>'last_name', ''));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to automatically create user profile
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to calculate compatibility score (simplified version)
CREATE OR REPLACE FUNCTION public.calculate_compatibility_score(user1_id UUID, user2_id UUID)
RETURNS INTEGER AS $$
DECLARE
  quiz1 RECORD;
  quiz2 RECORD;
  score INTEGER := 0;
  traits1 JSONB;
  traits2 JSONB;
BEGIN
  -- Get quiz results for both users
  SELECT personality_traits INTO traits1 FROM public.personality_quiz_results WHERE user_id = user1_id;
  SELECT personality_traits INTO traits2 FROM public.personality_quiz_results WHERE user_id = user2_id;
  
  IF traits1 IS NULL OR traits2 IS NULL THEN
    RETURN 0;
  END IF;
  
  -- Simple compatibility calculation (can be made more sophisticated)
  -- Lifestyle compatibility
  IF traits1->>'lifestyle' = traits2->>'lifestyle' THEN
    score := score + 15;
  END IF;
  
  -- Social energy compatibility
  IF traits1->>'social_energy' = traits2->>'social_energy' THEN
    score := score + 10;
  ELSIF (traits1->>'social_energy' = 'balanced' OR traits2->>'social_energy' = 'balanced') THEN
    score := score + 5;
  END IF;
  
  -- Cleanliness compatibility
  IF traits1->>'cleanliness' = traits2->>'cleanliness' THEN
    score := score + 20;
  END IF;
  
  -- Schedule compatibility
  IF traits1->>'schedule' = traits2->>'schedule' THEN
    score := score + 10;
  END IF;
  
  -- Communication style
  IF traits1->>'communication_style' = traits2->>'communication_style' THEN
    score := score + 15;
  END IF;
  
  -- Financial approach
  IF traits1->>'financial_approach' = traits2->>'financial_approach' THEN
    score := score + 10;
  END IF;
  
  -- Add bonus points for complementary traits
  IF (traits1->>'social_energy' = 'extrovert' AND traits2->>'social_energy' = 'introvert') OR
     (traits1->>'social_energy' = 'introvert' AND traits2->>'social_energy' = 'extrovert') THEN
    score := score + 10;
  END IF;
  
  -- Cap score at 100
  IF score > 100 THEN
    score := 100;
  END IF;
  
  RETURN score;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;